/*
 * generated by Xtext
 */
package edu.cmu.sei.eebm.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import edu.cmu.sei.eebm.eEBM.AndRefinement;
import edu.cmu.sei.eebm.eEBM.Conflict;
import edu.cmu.sei.eebm.eEBM.Description;
import edu.cmu.sei.eebm.eEBM.EEBMPackage;
import edu.cmu.sei.eebm.eEBM.Goal;
import edu.cmu.sei.eebm.eEBM.OrRefinement;
import edu.cmu.sei.eebm.eEBM.Preference;
import edu.cmu.sei.eebm.eEBM.Rationale;
import edu.cmu.sei.eebm.eEBM.Reference;
import edu.cmu.sei.eebm.eEBM.Roadmap;
import edu.cmu.sei.eebm.eEBM.Softgoal;
import edu.cmu.sei.eebm.eEBM.Task;
import edu.cmu.sei.eebm.services.EEBMGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class EEBMSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EEBMGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == EEBMPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case EEBMPackage.AND_REFINEMENT:
				sequence_AndRefinement(context, (AndRefinement) semanticObject); 
				return; 
			case EEBMPackage.CONFLICT:
				sequence_Conflict(context, (Conflict) semanticObject); 
				return; 
			case EEBMPackage.DESCRIPTION:
				sequence_Description(context, (Description) semanticObject); 
				return; 
			case EEBMPackage.GOAL:
				sequence_Goal(context, (Goal) semanticObject); 
				return; 
			case EEBMPackage.OR_REFINEMENT:
				sequence_OrRefinement(context, (OrRefinement) semanticObject); 
				return; 
			case EEBMPackage.PREFERENCE:
				sequence_Preference(context, (Preference) semanticObject); 
				return; 
			case EEBMPackage.RATIONALE:
				sequence_Rationale(context, (Rationale) semanticObject); 
				return; 
			case EEBMPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case EEBMPackage.ROADMAP:
				sequence_Roadmap(context, (Roadmap) semanticObject); 
				return; 
			case EEBMPackage.SOFTGOAL:
				sequence_Softgoal(context, (Softgoal) semanticObject); 
				return; 
			case EEBMPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (name=ID source+=[IntentionalElement|ID] dest+=[IntentionalElement|ID] dest+=[IntentionalElement|ID]*)
	 */
	protected void sequence_AndRefinement(EObject context, AndRefinement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID source=[IntentionalElement|ID] dest=[IntentionalElement|ID])
	 */
	protected void sequence_Conflict(EObject context, Conflict semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, EEBMPackage.Literals.CONFLICT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EEBMPackage.Literals.CONFLICT__NAME));
			if(transientValues.isValueTransient(semanticObject, EEBMPackage.Literals.CONFLICT__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EEBMPackage.Literals.CONFLICT__SOURCE));
			if(transientValues.isValueTransient(semanticObject, EEBMPackage.Literals.CONFLICT__DEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EEBMPackage.Literals.CONFLICT__DEST));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConflictAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConflictAccess().getSourceIntentionalElementIDTerminalRuleCall_3_0_1_0_1(), semanticObject.getSource());
		feeder.accept(grammarAccess.getConflictAccess().getDestIntentionalElementIDTerminalRuleCall_3_1_1_0_1(), semanticObject.getDest());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_Description(EObject context, Description semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, EEBMPackage.Literals.DESCRIPTION__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EEBMPackage.Literals.DESCRIPTION__TEXT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDescriptionAccess().getTextSTRINGTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         title=STRING? 
	 *         description=Description? 
	 *         priority=PriorityEnum? 
	 *         time=INT? 
	 *         cost=INT? 
	 *         benefit=INT? 
	 *         date=STRING? 
	 *         cod=INT? 
	 *         rationale=Rationale? 
	 *         ref=Reference?
	 *     )
	 */
	protected void sequence_Goal(EObject context, Goal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID source=[IntentionalElement|ID] dest+=[IntentionalElement|ID] dest+=[IntentionalElement|ID]*)
	 */
	protected void sequence_OrRefinement(EObject context, OrRefinement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (first=[IntentionalElement|ID] last=[IntentionalElement|ID])
	 */
	protected void sequence_Preference(EObject context, Preference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, EEBMPackage.Literals.PREFERENCE__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EEBMPackage.Literals.PREFERENCE__FIRST));
			if(transientValues.isValueTransient(semanticObject, EEBMPackage.Literals.PREFERENCE__LAST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EEBMPackage.Literals.PREFERENCE__LAST));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPreferenceAccess().getFirstIntentionalElementIDTerminalRuleCall_1_0_1(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getPreferenceAccess().getLastIntentionalElementIDTerminalRuleCall_3_0_1(), semanticObject.getLast());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_Rationale(EObject context, Rationale semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, EEBMPackage.Literals.RATIONALE__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EEBMPackage.Literals.RATIONALE__TEXT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRationaleAccess().getTextSTRINGTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     docReference+=STRING
	 */
	protected void sequence_Reference(EObject context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='Roadmap'? components+=IntentionalElement* (relations+=Refinement | relations+=Conflict)*)
	 */
	protected void sequence_Roadmap(EObject context, Roadmap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         title=STRING? 
	 *         description=Description? 
	 *         priority=PriorityEnum? 
	 *         time=INT? 
	 *         cost=INT? 
	 *         benefit=INT? 
	 *         date=STRING? 
	 *         cod=INT? 
	 *         rationale=Rationale? 
	 *         ref=Reference?
	 *     )
	 */
	protected void sequence_Softgoal(EObject context, Softgoal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         title=STRING? 
	 *         description=Description? 
	 *         priority=PriorityEnum? 
	 *         time=INT? 
	 *         cost=INT? 
	 *         benefit=INT? 
	 *         date=STRING? 
	 *         cod=INT?
	 *     )
	 */
	protected void sequence_Task(EObject context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
